2章 プログラムの意味
------------
## この章の概要
プログラムはただの文字の羅列ではなくプログラマのその当時の思考のアイデアのスナップショットである。  
コードを意味あるものにするための仕組みをRubyで簡単な言語を実装しながら学んでいく。

## 2.1 「意味」の意味
プログラム言語を記述するためには「構文(プログラムがどう見えるか)」と「意味論(プログラムが何を意味するか)」が必要。  
記述アプローチとしては3つのパターンがある
### 実装による仕様
実際に動くコンパイラやインタプリタが仕様になっている。別実装を作る場合、「リファレンス実装の振る舞いを忠実にまねる」という作業が求められる。  
Ruby(MRI)などがこれに当たる。
### 公式文書としての仕様書
C++,Java,ECMAScriptなどがこれに当たる。  
公文書として検討した結果の仕様なので、そこにある仕様は合理的なものである可能性が高いが、仕様書を読むのが大変。

### 数学的テクニックを駆使した仕様書

## 2.2 構文
構文とはプログラム文字列を有効なプログラムかどうかを判定する規則の集まりである。
構文はパーサによって抽象構文木(AST)に変換される

> 抽象構文木（abstract syntax tree、AST）とは、通常の構文木（具象構文木、あるいはparse treeとも言う）から、言語の意味に関係ない情報を取り除き、意味に関係ある情報のみを取り出した（抽象した）木構造のデータ構造である。
> 理論的には、有限なラベル付き有向木であり、分岐点（internal node）に演算子、葉（leaf node）にそのオペランドを対応させたものである。つまり、葉は変数や定数に対応する。

[抽象構文木 - Wikipedia](http://ja.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E6%A7%8B%E6%96%87%E6%9C%A8)

## 2.3 操作的意味論
抽象機械(abstract machine)を使ってある言語が実行されたときの意味(振る舞い)を記述する。

### 2.3.1 スモールステップ意味論
構文を小さなステップ(スモールステップ)で繰り返し簡約(reduce)することによって、プログラムを評価する。

```
(1 * 2) + (3 * 4)
-> 2 + (3 * 4)
-> 2 + 12
-> 14
```

以降、SIMPLEという名の簡単な言語を実装しながらスモールステップの方法で抽象機械を記述する。

#### 2.3.1.1 式
* 言語の構文になる要素(数値、演算子など)ごとにクラスを定義し、そのインスタンスからなる木として抽象構文木を表現する  
* 式ごとに簡約可能か(reducible?)と簡約可能であれば簡約(reduce)メソッドを持つ  
* 変数を表現するために環境(environment)をHashオブジェクトとして各式のreduceメソッドに渡す
* 抽象機械は簡約可能で無くなるまで式を簡約し続ける

[式クラス](TODO: リンク張る)  
[抽象機械](TODO: リンク張る)

#### 2.3.1.2 文
* 文は、評価されることで抽象機械の状態を変更する
 * 式は環境を変化させない(pure), 文は環境を変化させる(impure)

[文クラス](TODO: リンク張る)

#### 2.3.1.3 正当性
SIMPLEはこれまでの実装内容だと「構文的には正しいがプログラム的には正しく無い」場合が存在してしまう。  
```
(例)
x = true; x = x + 1
```
これを防ぐために、静的意味論を使って動作する前にプログラムの正しさをチェックする(9章)

#### 2.3.1.4 応用
同じ構文でも意味の付け方が変われば言語仕様も変わる。設計者の判断次第。

* SIMPLEは左から式を評価するが、Rubyも同様
* SIMPLEは式と文が明確に分かれているが、Rubyは式と文は同じものである

### 2.3.2 ビッグステップ意味論
* スモールステップ意味論
 * 操作を細かい簡約の組み合わせと反復で最終的な仕様を導く
 * 間接的で処理順序が決まっている
* ビッグステップ意味論
 * 式や文から直接結果を導く方法を記述する
  * 再帰を利用する
  * スモールステップに比べ、詳細が欠けている場合がある
   * 処理順序が定義されていない、など

#### 2.3.2.1 式
式は自分自身が評価されるか、実行後別の式に評価されるかのどちらかしかない

#### 2.3.2.2 文
文は初期の文と環境を最終的な環境に変換するプロセスを記述する

#### 2.3.2.3 応用
スモールステップ意味論はコールスタックは構文木の深度が最大値だが、ビッグステップ意味論の場合は再帰により、より深くなる

* スモールステップは各式、文自体が抽象機械に役に立つ中間結果を生成する
* ビッグステップは1度の計算で結果を出すための途中の道順は人、もしくはマシンにおまかせ
* やりたいことによって使い分ける
 * 効率の良い実装を構築する
 * プログラムの特性を証明する
 * 最適化を工夫する
 * etc.

今までの流れで2つのインタプリタを作れた。

* インタプリタを作ることは言語の意味を説明することである。
* 他にも数学的記法でつくることも出来る。

## 2.4 表示的意味論
ある言語を別の表現に変換する。操作的意味論より抽象的なアプローチ。  
例えば英語を日本語に翻訳するのは表示的意味論の領域である。  
  
ここではSIMPLEをRubyに変換することで表示的意味論を学ぶ

### 2.4.1 式
Rubyで「環境を引数にとり、評価結果の値を返す」というのをprocを使って表現する

### 2.4.2 文
Rubyで「評価結果として更新された環境を返す」というのをHashの更新を行うprocコードで表現する

