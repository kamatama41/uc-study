2章 プログラムの意味
------------
## この章の概要
プログラムはただの文字の羅列ではなくプログラマのその当時の思考のアイデアのスナップショットである。  
コードを意味あるものにするための仕組みをRubyで簡単な言語を実装しながら学んでいく。

## 2.1 「意味」の意味
プログラム言語を記述するためには「構文(プログラムがどう見えるか)」と「意味論(プログラムが何を意味するか)」が必要。  
記述アプローチとしては3つのパターンがある
### 実装による仕様
実際に動くコンパイラやインタプリタが仕様になっている。別実装を作る場合、「リファレンス実装の振る舞いを忠実にまねる」という作業が求められる。  
Ruby(MRI)などがこれに当たる。
### 公式文書としての仕様書
C++,Java,ECMAScriptなどがこれに当たる。  
公文書として検討した結果の仕様なので、そこにある仕様は合理的なものである可能性が高いが、仕様書を読むのが大変。

### 数学的テクニックを駆使した仕様書

## 2.2 構文
構文とはプログラム文字列を有効なプログラムかどうかを判定する規則の集まりである。
構文はパーサによって抽象構文木(AST)に変換される

> 抽象構文木（abstract syntax tree、AST）とは、通常の構文木（具象構文木、あるいはparse treeとも言う）から、言語の意味に関係ない情報を取り除き、意味に関係ある情報のみを取り出した（抽象した）木構造のデータ構造である。
> 理論的には、有限なラベル付き有向木であり、分岐点（internal node）に演算子、葉（leaf node）にそのオペランドを対応させたものである。つまり、葉は変数や定数に対応する。

[抽象構文木 - Wikipedia](http://ja.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E6%A7%8B%E6%96%87%E6%9C%A8)

## 2.3 操作的意味論
抽象機械(abstract machine)を使ってある言語が実行されたときの意味(振る舞い)を記述する。

### 2.3.1 スモールステップ意味論
構文を小さなステップ(スモールステップ)で繰り返し簡約(reduce)することによって、プログラムを評価する。

```
(1 * 2) + (3 * 4)
-> 2 + (3 * 4)
-> 2 + 12
-> 14
```

